
Sum Pair closest to target


class Solution {
  public:
    vector<int> sumClosest(vector<int>& arr, int target) {
        // code here
        sort(arr.begin(),arr.end());
        int n=arr.size();
        if(n<2){
            return {};
        }
        int ele1=arr[0];
        int ele2=arr[n-1];
        int diff=INT_MAX;
        int start=0;
        int end=n-1;
        
        while(start<end){
            int sum = arr[start] + arr[end];
            int currdiff = abs(target -sum);
            
            if(currdiff < diff){
                diff = currdiff;
                ele1= arr[start];
                ele2=arr[end];
            }
            else if(currdiff==diff){
                if(abs(arr[start]-arr[end])> abs(ele1-ele2)){
                    ele1=arr[start];
                    ele2=arr[end];
                }
            }
            if(sum>target)end--;
            else start++;
        }
        
        return {ele1,ele2};







Merge Without Extra Space


class Solution {
public:
    void mergeArrays(vector<int>& a, vector<int>& b) {
        int n = a.size();
        int m = b.size();

        auto nextGap = [&](int gap) {
            if (gap <= 1) return 0;
            return (gap / 2) + (gap % 2);
        };

        int gap = nextGap(n + m);

        while (gap > 0) {
            int i = 0;
            int j = gap;

            while (j < n + m) {
                if (i < n && j < n) {
                    if (a[i] > a[j])
                        swap(a[i], a[j]);
                }
                else if (i < n && j >= n) {
                    if (a[i] > b[j - n])
                        swap(a[i], b[j - n]);
                }
                else {
                    if (b[i - n] > b[j - n])
                        swap(b[i - n], b[j - n]);
                }

                i++;
                j++;
            }

            gap = nextGap(gap);
        }
    }
};

        
        
    }
};

